#' Sunburst plot
#'
#' This function arranges the hierarchical data and fills based on the counts for each category and level.
#'
#' This function arranges a hierarchical data set into a dart-style chart, which is then partitioned and colored based on the data structure.
#' The outer most section displays the number of elements (counts) in the lowest (most specific) hierarchical level.
#' The user has the option to fill the outer level with user specified values given to \code{fill_by}
#' or to fill with the mean value \code{fill_by_mean}. See \code{Details}.
#'
#' @param DATA                       - Data frame containing hierarchical data by columns, where the left column is the highest level and the right column the lowest one.
#'
#' @param centerLabel                - optional. String to be used for centre label. Default (\code{""}; i.e. no text).
#'
#' @param ANGLE                      - optional. Should the angle of the text be adjusted to the position where it's at? Default (\code{FALSE}; i.e. horizontal text).
#'
#' @param fill_by                    - optional. Numeric vector containing values to be used to fill outer most ring (see Details). Default (\code{NULL}).
#'
#' @param fill_by_mean               - optional. Should the categories in the inner rings be filled (colored) by the mean of the fill_by value provided. Default (\code{FALSE}).
#'
#' @param outer_text                 - optional. Should the text from the lowest level (right column) be included? Default (\code{TRUE}).
#'
#' @param outer_text_levelN_minus_1  - optional. Should the text from the second lowest level (second column from right) be included? Default (\code{TRUE}).
#'
#' @param legend_name                - optional. Default ("Counts\\n"; i.e. have space between name and legend bar).
#'
#' @param sunburst                   - optional. Should the sunburst be made (default) or should the output be bars? Default (\code{TRUE,}).
#'
#' @param setMax                     - optional. Numerical value to set the maximum limit. Categories with higher values than those specified will be excluded, making them light blue.  Default (\code{NULL}).
#'
#' @param setMin                     - optional. Numerical value to set the minimun limit. Categories with lower  values than those specified will be excluded, making them light blue.  Default (\code{NULL}).
#'
#' @param textSize                   - optional. Numerical value to set the text size. Default (\code{NULL}).
#'
#' @param textColour                 - optional. String to set the text colour. Default ("black").
#'
#' @param Filename                   - optional. A character vector containing the file path to save image(s). The device to save is determined by file extension.
#'                                         Default (\code{""}; i.e. printed to device, file not written).
#'
#' @param WIDTH                      - optional. Width  size for file. Note that text size in plot scales with \code{WIDTH}. Default (25 in).
#'
#' @param HEIGHT                     - optional. Height size for file. Default (25 in).
#'
#' @return
#' List containing the \code{$DATA} used to generate the plot and the plot itself as a ggplot object \code{$p}.
#'
#' @details
#' The sunburst is generated by having a ring containing the hierarchical data from highest level (most generic) at the centre,
#' followed by concentric rings that go out as the data becomes more specific.
#' The outer-most ring is colored (filled) by the number of members (counts) in that category.
#' The hierarchy is conserved throughout the data levels.
#'
#' \preformatted{
#' LEVEL_1   LEVEL_2   LEVEL_3
#'       a       aa       aa1
#'       a       aa       aa2
#'       a       ab  		  ab1
#'       a       ab  		  ab2
#'       b       ba  		  ba1
#'       b       ba  		  ba2
#'       b       bb  		  bb1
#'       b       bb  		  bb2
#'       c       ca  		  ca1
#'       c       ca  		  ca2
#'       c       cb  		  cb1
#'       c       cb  		  cb2
#' }
#'
#' The above data would result in a sunburst plot that would have 3 categories in the inner-most ring, each with 2 categories in the second ring (6 total)
#' and 12 categories in the outer ring, one for each of the second level categories.
#' Therefore, the counts would all be 1 (see the first example for a case with different levels).
#'
#' \code{fill_by} allows the user to display other values associated with the outer-most categories, such as the module fraction completeness (mfc), rather than the membership count.
#' If \code{fill_by_mean} is set to \code{TRUE}, then the inner rings are also filled (colored) based on the mean of the \code{fill_by} value of the data making up the category.
#'
#' \code{fill_by} should contain as many entries as there are categories at the last level.
#' If more are provided, only the required entries will be used
#' (i.e. if 5 values are provided for data with 3 categories, only the first 3 values will be used).
#' Only as many entries as there are rows in \code{DATA} are allowed.
#'
#' Function developed by expanding and modifying Yahia El Gamal's blog post "Create Basic Sunburst Graphs with ggplot2"
#' ([https://medium.com/optima-blog/create-basic-sunburst-graphs-with-ggplot2-7d7484d92c61])
#'
#' @examples
#' data(data_example_sunburst)
#'
#' #  CLASS_I            CLASS_II            CLASS_III            NAME_SHORT
#' #	Pathway module    Carbohydrate & lipid metabolism    Fatty acid metabolism    beta-Oxidation
#' #	Pathway module        Energy metabolism    Methane metabolism    Methanogenesis, from methanol
#' #	Pathway module        Energy metabolism    Methane metabolism    Methanogenesis, from acetate
#' #	Pathway module        Energy metabolism    Carbon fixation        Reductive acetyl-CoA pathway
#' #	Pathway module        Energy metabolism    Nitrogen metabolism    Dissimilatory nitrate reduction
#' #	Pathway module        Energy metabolism    Methane metabolism    Methanogenesis, from methylamine
#' #	Pathway module        Energy metabolism    Methane metabolism    Methanogenesis, from CO2
#' #	Pathway module        Energy metabolism    Sulfur metabolism    Dissimilatory sulfate reduction
#'
#' # Simplest plot using count data.
#' plot_data <- plot_sunburst(sunbust_data,WIDTH = 8) # WIDTH scales text size
#'
#' # Specify values to be used for outer ring (lowest level) and change legend name accordingly
#'
#' data(data_example_sunburst_fill_by)
#'         # mcf for the modules associated with the data shown above for an example dataset.
#' plot_data <- plot_sunburst(data_example_sunburst,centerLabel = "Org A",
#'                            fill_by = data_example_sunburst_fill_by,outer_text = F,WIDTH = 8,
#'                            legend_name = "fill_by")
#'
#' # Also fill inner rings (levels) according to the mean values determined by fill_by.
#' plot_data <- plot_sunburst(data_example_sunburst,centerLabel = "Org A",
#'                            fill_by = data_example_sunburst_fill_by,fill_by_mean = T,
#'                            outer_text = F,WIDTH = 8,legend_name = "fill_by")
#'
#' @export

###
plot_sunburst <- function(DATA,centerLabel = "",ANGLE = FALSE,fill_by = NULL,fill_by_mean = FALSE,outer_text = TRUE,outer_text_levelN_minus_1 = TRUE,
                          legend_name = "Counts\n",sunburst=TRUE,setMax = NULL,setMin = NULL,textSize = NULL,textColour = "black",
                          Filename = "",WIDTH = 25,HEIGHT = 25,...){

  ##### MANAGE INPUT ----
  stopifnot(is.data.frame(DATA)||is.matrix(DATA))
  stopifnot(is.logical(ANGLE),is.logical(fill_by_mean),is.logical(outer_text),is.logical(outer_text_levelN_minus_1),is.logical(sunburst))
  stopifnot(is.null(setMax)||is.numeric(setMax))
  stopifnot(is.null(setMin)||is.numeric(setMin))
  stopifnot(is.character(legend_name),is.character(Filename))
  stopifnot(is.numeric(WIDTH),is.numeric(HEIGHT))
  stopifnot(is.numeric(textSize)||is.null(textSize))
  stopifnot(is.character(textColour))

  # fill_by
  stopifnot(is.null(fill_by)||(is.numeric(fill_by)&&(nrow(DATA)<=length(fill_by))))

  # text Size and colour
  if(is.null(textSize)) textSize <- WIDTH/3
  if(length(textColour)>1) textColour <- textColour[1]

  # TEXT ANGLES FUNCTION
  compute_angle = function(perc){
    angle = -1
    if(perc < 0.25) # 1st q [90,0]
      angle = 90 - (perc/0.25) * 90
    else if(perc < 0.5) # 2nd q [0, -90]
      angle = (perc-0.25) / 0.25 * -90
    else if(perc < 0.75) # 3rd q [90, 0]
      angle = 90 - ((perc-0.5) / 0.25 * 90)
    else if(perc < 1.00) # last q [0, -90]
      angle = ((perc -0.75)/0.25) * -90
    return(angle)
  }

  ###### DEFINE LEVELS ########
  nLevels <- ncol(DATA)
  # Order DATA hierarchically
  for(N in nLevels:1) DATA <- DATA[order(DATA[,N]),]

  ### REMAINING LEVELS - DATA ----
  tmp     <- data.frame(Level = rep(1,length(unique(DATA[,1]))),Group = unique(DATA[,1]),stringsAsFactors = F)

  for(i in 1:length(unique(DATA[,1])))       tmp$counts[i] <- length(which(DATA[,1]==tmp$Group[i]))

  ## fill_by
  tmp$fillBy <- NA
  if(!is.null(fill_by)&&fill_by_mean){
    for(N in 1:nrow(tmp)){
      index         <- which(DATA[,1]==tmp$Group[N])
      # tmp$fillBy[N] <- sum(fill_by[na.omit(match(rownames(DATA)[index],names(fill_by)))])/tmp$counts[N]
      tmp$fillBy[N] <- sum(fill_by[index])/tmp$counts[N]
    }
  }
  tmp$cum_counts  <- cumsum(tmp$counts)
  tmp$pos         <- tmp$cum_counts - tmp$counts/2 # Text position: cumulative_sum - current_value/2
  tmp$group_by    <- 1:nrow(tmp)
  tmp$labels_x <- tmp$Level

  for(N in 2:nLevels){
    tmp_2 <- NULL
    if(N>2){
      tmp_DATA <- cbind(apply(DATA[,1:(N-1)],1,paste, collapse =";"),DATA[,N])
    }else{
      tmp_DATA <- DATA
    }

    exclude_index <- NULL
    for(NN in 1:length(unique(tmp_DATA[,1]))){
      sublevel_index  <- grep(unique(tmp_DATA[,1])[NN],tmp_DATA[,1],fixed = T)
      Group           <- unique(tmp_DATA[sublevel_index,2])
      nSubLev         <- length(Group)
      Level           <- rep(N,nSubLev)

      # OTHER INFO
      counts   <- cum_counts <- pos <- angle <- fillBy <- numeric(nSubLev)
      group_by <- labels_x   <- character(nSubLev)

      for(i in 1:nSubLev){
        this_sublevel_index <-  grep(Group[i],tmp_DATA[sublevel_index,2],fixed = T)
        counts[i] <- length(which(tmp_DATA[sublevel_index,2]==Group[i]))
        if(!is.null(fill_by)&&fill_by_mean){
         fillBy[i] <- sum(fill_by[sublevel_index[this_sublevel_index]])/counts[i]
        }
      exclude_index   <- c(exclude_index,sublevel_index)
      }
      tmp_2 <- rbind(tmp_2,cbind(Level,Group,counts,fillBy))#,cum_counts,pos,group_by,angle,labels_x))
    }
      tmp_2             <- as.data.frame(tmp_2, stringsAsFactors = F)
      tmp_2$counts      <- as.numeric(tmp_2$counts)
      tmp_2$cum_counts  <- cumsum(tmp_2$counts)
      tmp_2$pos         <- tmp_2$cum_counts - tmp_2$counts/2 # Text position: cumulative_sum - current_value/2
      tmp_2$group_by    <- 1:nrow(tmp_2)

      if(N==nLevels){       # &&outer_text
        tmp_2$labels_x  <- as.numeric(tmp_2$Level)+1
      }else{
        tmp_2$labels_x  <- tmp_2$Level
      }
    tmp   <- rbind(tmp,tmp_2)
  }

  LEVELS <- as.data.frame(tmp,stringAsFactor = F)
  rm(tmp,tmp_2)

  # ADD ZERO LEVEL
  LEVELS        <- rbind(c(0,centerLabel,0,0,0,0,1,0),LEVELS)

  # MORE DATA ----
  last_level_index  <- which(LEVELS$Level==nLevels)
  LEVELS$LABELS <- LEVELS$Group
  if(!outer_text) LEVELS$LABELS[last_level_index] <- ""
  if(!outer_text_levelN_minus_1) LEVELS$LABELS[which(LEVELS$Level==(nLevels-1))] <- ""

  ### FILL BY ----
  if(!is.null(fill_by)){
    if(!fill_by_mean){
      LEVELS$fillBy     <- -10
    }
    # IF fill_by is the same length, use those values. If not, use first required entries.
    if(length(fill_by)==length(last_level_index)){
      LEVELS$fillBy[last_level_index] <- fill_by
    } else{
      warning(paste("fill_by has different length than last level values. Using only the first",length(last_level_index),"fill_by entries."))
      LEVELS$fillBy[last_level_index] <- fill_by[1:length(last_level_index)]
    }
    }else{
    LEVELS$fillBy <- LEVELS$counts
  }
  # FORMAT DATA
  LEVELS$Level      <- as.numeric(LEVELS$Level)
  LEVELS$labels_x   <- as.numeric(LEVELS$labels_x)
  LEVELS$pos        <- as.numeric(LEVELS$pos)
  LEVELS$counts     <- as.numeric(LEVELS$counts)
  LEVELS$cum_counts <- as.numeric(LEVELS$cum_counts)
  LEVELS$fillBy     <- as.numeric(LEVELS$fillBy)

  LEVELS$angle  <- 0
  if(sunburst) if(ANGLE) for(i in 1:nrow(LEVELS)) LEVELS$angle[i]     <- compute_angle((LEVELS$cum_counts[i] - LEVELS$counts[i]/2) / nrow(DATA))

  ### REMAINING LEVELS - PLOT ----
    # use stacked bar chart and then rotate them around the y axis to build to donughts. So letâ€™s do a stacked bar charts
  p <- ggplot2::ggplot(LEVELS, ggplot2::aes(x=Level, y=counts, fill=fillBy)) +
        ggplot2::geom_bar(position="stack", stat="identity", width=1,colour="white",size=0.2) +
        ggplot2::theme_bw()

  # ADD TEXT AFTER SO THAT IT'S ON TOP
  p <- p + ggplot2::geom_text(data=LEVELS,ggplot2::aes(x=labels_x, y=pos,label=LABELS, angle=angle),size = textSize,colour=textColour,hjust=0.5,vjust=0.25)

  if(sunburst){
    p <- p + ggplot2::coord_polar('y')
          #  'coord_polar' takes an argument 'y'. Which tells it to rotate around the y axis (not the x axis).
  }

  # FINAL MODIFICATIONS ----
  if(is.null(setMax)){
    round_out <- misc_axisRound(LEVELS$fillBy)
    MAX       <- round_out$max
  }else{
    MAX       <- setMax
  }
  if(is.null(setMin)){
    round_out <- misc_axisRound(LEVELS$fillBy[last_level_index])
    MIN       <- round_out$min
  }else{
    MIN       <- setMin
  }
  p <- p + ggplot2::xlab(NULL) + ggplot2::ylab(NULL) +
            ggplot2::scale_fill_distiller(palette = "Spectral", name = legend_name, limits = c(MIN,MAX),na.value = 'lightblue') + # #e7e1ef #c994c7
            ggplot2::theme(legend.position = "right",  # Legend
                   legend.key = ggplot2::element_rect(colour = 'black'),
                   legend.key.size = ggplot2::unit(WIDTH/14, "cm"),
                   legend.text  = ggplot2::element_text(size=WIDTH*0.95),
                   legend.title = ggplot2::element_text(size=WIDTH*1.1)) +
            ggplot2::theme(axis.line  = ggplot2::element_blank(), panel.grid = ggplot2::element_blank(), panel.border = ggplot2::element_blank()) +
            ggplot2::theme(axis.title = ggplot2::element_blank(),axis.text   = ggplot2::element_blank(), axis.ticks   = ggplot2::element_blank()) +
            ggplot2::theme(plot.margin = ggplot2::unit(c(0,0.5,0,0),units = "in") ) # top, right, bottom, and left

  # p

  # WRITE PLOT TO FILE ----
 if(Filename != ""){
   for(FF in Filename) ggplot2::ggsave(filename = FF,plot = p,width = WIDTH,height = HEIGHT)
 }else{
   print(p)
 }

  # RETURN PLOT  ----
  output <- list(DATA = LEVELS,p = p)
  return(output)

}
